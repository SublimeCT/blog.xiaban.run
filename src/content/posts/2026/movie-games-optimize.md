---
title: AI 互动剧情类游戏生成工具开发记录2 - 构建工作流
published: 2026-01-08
description: '在上一篇文章中, 介绍了一下我要做的互动剧情类游戏生成器, 然后分析了目前面临的严重影响使用的问题, 现在我们来通过构建工作流的方式来解决这些问题'
image: './assets/images/movie-games-optimize-cover.png'
tags: [
  '工作流',
  '构建工作流',
  'Vibe Coding',
  'AI',
  'Movie Games',
  'GLM',
  'DeepSeek',
  'ChatGPT',
  '互动电影游戏',
  '互动剧情类游戏',
  '互动剧情类游戏生成器',
]
category: '探索'
draft: true 
lang: 'zh-CN'
---

在 [上一篇文章](/movie-games-record) 中, 介绍了一下我要做的互动剧情类游戏生成器, 然后分析了目前面临的严重影响使用的问题, 现在我们来通过构建工作流的方式来解决这些问题

## 失败的设计
在现有的设计方案中, **我把一切都交给了 LLM**, 并且在 `propmpt` 中精心编写了各种限制, 我本以为它会生成符合所有要求的 `JSON`, 但是总是出现各种问题

倘若这是一个没有与 LLM 交互的项目, 那总会找到解决方案, 因为 **程序输出的结果是确定的, 而 LLM 输出的结构是不确定的**

### 超长的上下文

现有的提示词(**已省略部分内容**)如下:
```markdown
# 角色定义
你是一位享誉全球的互动电影游戏编剧和总导演。你擅长创作引人入胜、逻辑严密且充满情感冲击力的多分支剧情。 你的任务是根据用户提供的主题，创作一个完整的互动电影剧本，并将其直接输出为符合 TypeScript 接口定义的 JSON 格式。

# 用户输入主题
{}
# 一、核心叙事与风格要求
- 第一人称沉浸式叙事：所有的 `node.content` 必须使用 **第一人称 ("我")** 进行叙述。玩家就是主角，代入感必须极强。
- 剧情深度与质量：
    - 拒绝流水账、拒绝平铺直叙、拒绝假大空。
    - 必须具备电影剧本般的 **真实感、细腻度与情感张力**。
    - 严禁任何无意义的故事情节或重复啰嗦的废话。
- 语言指定：所有剧情内容必须使用 **{}** 撰写。

# 二、基础结构与格式约束
- JSON 结构规范：
  - 严格遵循下方的 `TypeScript` 类型定义。
  - 禁止返回 `meta` / `projectId` / `nodes[].id` / `version` / `owner` / `provenance` 等字段。
  - 结局分离：所有的结局节点必须定义在顶层的 `endings` 字段中。
  - ID 格式：
    - `nodes` 的 Key 必须是 **纯数字字符串** (例如 "1", "2", "3"...)。
    - **绝对禁止** 使用 `n_` 前缀 (如 `n_1`, `n_start` 等都是错误的)。
    - 唯一例外：起始节点的 Key 必须固定为 **"start"**。
  - 结局引用：`StoryNode` 中的 `choices` 若指向结局，必须引用 `endings` 中的 key。

# 三、数值硬性约束 (校验失败将视为错误)
- 节点总数：`nodes` 的数量必须在 **45 到 85** 之间。
- 结局数量：`endings` 的数量必须在 **4 到 6** 之间。
- 单节点字数：每个节点的 `content` (AI 智能扩写) 字数必须严格控制在 **45 到 65 字** 之间。
- 节点内容：每个节点的 `content` 禁止出现任何中文或者英文的双引号, 双引号必须使用单引号代替
- 路径深度：必须保证绝大多数的故事线都经过 **至少 12 个节点**。

...
# 六、结局触发机制
- 灵活结局：`endings` 的 Key 不再固定，可以根据剧情自由命名 (如 `ending_hero`, `ending_regret` 等)。
- 结局描述：每个结局的 `description` 长度不能超过 **40 个字**。
- 快速通道：**必须包含一个可以快速到达的结局路径**。
  - 例如：从 Start -> 节点 3 -> 节点 5 -> (选择某选项) -> 直接到达结局。
  - 也就是说，在较早的层级 (如 Level 3-5) 就允许通过特定选项直接进入结局。
- 互斥规则：
  - `nodes` 中的节点 **不允许** 包含 `endingKey` 属性。
  - 结局只能通过 `choices.nextNodeId` 指向 `endings` 的 Key 来触发。

# 用户提供的角色清单 (JSON)
{}
# TypeScript 类型定义 (Schema)
typescript {}
# 输出规则
- 输出必须是 **纯 JSON** 文本。
- **不要** 包含 markdown 代码块标记。
- `nodes` 数量：**45~85**。
- `endings` 数量：**3~6**。
- 必须包含 `start` 节点。
- 禁止出现任何游离节点(从 start 节点开始到达不了的节点)
- **每层节点数量不能超过 5 个, 在每次输出节点时都要检查是否超过这个数量值**
- **必须从最开始就要规划节点数量, 任何节点的选项引用的节点 id 都不允许超过这个数量值**
开始创作！
```

其中的 `{}` 是用户的输入(标题 / 简介 / 角色列表) 还有 `ts` 类型定义

此时 LLM 同时承担了:
- 🎨 高质量文学创作（电影级叙事）
- 🧠 全局规划（45–85 节点、12–15 层、选项比例、收束率）
- 🧮 严格数学约束满足（DAG、ID 递增、层级宽度、百分比）
- 🧾 精确 JSON Schema 输出

最终造成了 LLM 在 **长上下文生成** 时出现了 遗忘 / 幻觉 / 格式约束失败 的问题

> [!TIP]
> 出现问题的原因并不是因为 `prompt` 写的不够详细, 而是因为
> - **超长的内容已经超过了 `LLM` 输出稳定性的边界**
> - **`LLM` 并不会对剧情内容进行反复打磨, 而是一次性生成**
> - **约束越多, 输出越趋同和保守**
> - **模型并不会 记住整部故事，它只是在概率上 看过**

### 剧情树设计存在的问题

![现有的剧情树设计](./assets/images/movie-games-optimize-mow.excalidraw.svg)

以上是现有的剧情树设计, 上方是剧情树中的节点, 下方是结局节点, 从 `Start Node` 节点开始, 每个节点都指向下一个层级(`level`)的某个节点(或者结局节点), 最终到达 `Endings` 节点结束, 通过设计图很容易发现一些问题:

- 生成了 `21` 个节点, 最终玩家游玩一次只经过 `3 ~ 7` 个节点, 实际节点利用率只有 `14%` ~ `33%`, **大部分节点是玩家必须多次游玩才能到达, 但实际上很少会有玩家会玩第二次**
- 上一篇文章介绍的 [剧情状态丢失](../movie-games-record/#剧情状态丢失) 问题

## 解决方案
我把问题分别发送给了 `ChatGPT` / `Gemini` / `DeepSeek`, 有趣的是, 它们的给出的方案既有重叠的部分, 也有自己独到的一面

为了解决在长上下文场景下大模型输出的不确定性问题, 我们可以将 prompt 拆解为多个 promot, 这样做就能做到:

- 每个 prompt 只完成一件事
- 减少每个 prompt 的长度
- 缩短整个剧情生成的时间

### 共同点
`ChatGPT` / `Gemini` / `DeepSeek` 给出的方案共同之处在于:

1. 结构生成 与 内容生成 分离
2. 剧情节点并发生成
3. 引入剧情状态配置

不同之处在于:
- 剧情状态设计
- 剧情节点的并发生成方式

可以点击查看所有模型的对话:
- [ChatGPT](https://chatgpt.com/share/6964a414-ade4-800b-b839-5b53fd8a1ce4)
- [Gemini](https://gemini.google.com/share/3359fe7f9880)
- [DeepSeek](https://chat.deepseek.com/share/pysplefy24u9rk71gc)

### ChatGPT 激进的拆解派
[点击这里](https://chatgpt.com/share/6964a414-ade4-800b-b839-5b53fd8a1ce4) 查看完整对话

#### Prompt A 节点规划
这个 Prompt 只做一件事: **不关注具体的剧情内容, 只生成剧情数的结构**, 具体职责为:

- 确定 `Level` 层数
- 每个 `Level` 的节点数
- 哪些 `Level` 是收束点
- 哪些节点是复用节点
- 哪些节点允许直达结局
- 每个节点的 **简短摘要**

#### Prompt B 生成起始节点和结局节点
由于起始节点和结局节点的特殊性, 需要先进行生成

#### Prompt C 好感度数据
好感度系统是基于角色的 **剧情状态** 设计方式, 在众多游戏中, 都或多或少的存在好感度系统, 例如:

- 玩家选择了某个支线任务, 与某个角色共同完成了某段剧情, 在后续的主线中就会再次遇到这个角色, 而如果不做这个支线任务, 就不会遇到他
- 需要做出一系列偏向与某个角色的选择, 后续才能进入此角色的故事线

#### Prompt D 节点内容生成
这个 Prompt 只做一件事: **生成单个节点内容**, 具体实现为:

在 prompt 中加入 `Prompt A` 生成的某个节点的信息(**只包含此节点的信息, 不包含其他节点的信息**), 包含:
- 故事的基本信息
- 有几个选项
- 起始节点和结局节点
- 节点简短摘要

#### 本地化数据校验
生成完节点树数据后, 通过程序校验数据

#### 缺点

`ChatGPT` 使用了先生成(包含节点 **简短摘要** 的)节点树结构, 然后再每个节点单独生成具体的内容和选项的方式, 这种方式虽然对长上下文进行了合理的拆解, 但考虑的过于简单

- 在生成剧情树结构时生成 简短摘要, **依然存在 长上下文场景下 LLM 输出不稳定的问题**
- 每个节点单独生成时, LLM 会忽视大量的细节, 而且完全 **没有解决 剧情状态 丢失的问题**
- **本地化校验 在本项目中不应该存在**, 因为一旦校验失败就会重新生成, 耗时进一步增加

因此这个方案是失败的

### DeepSeek 分层生成策略
[点击这里](https://chat.deepseek.com/share/pysplefy24u9rk71gc) 查看完整对话

DeepSeek 的方案基本与 ChatGPT 方案一致, 唯一的不同点在于: 使用了

- **生成故事大纲, 而非节点树结构**
- **分层生成策略**

#### 故事大纲
```rust
fn phase1_prompt(theme: &str, characters: &[Character]) -> String {
    format!(
        r#"作为顶级互动电影编剧，请设计一个故事大纲：

主题：{}
角色：{}

请设计：
1. 核心冲突（50字以内）
2. 4-6个可能的结局方向（每个1句话）
3. 关键剧情转折点（3-5个）
4. 角色关系图谱

返回JSON格式：{{
    "conflict": "核心冲突描述",
    "endings": ["结局1", "结局2"...],
    "turning_points": ["转折1", "转折2"...],
    "character_relations": {{"角色1": ["与角色2的关系", ...]}}
}}
"#,
        theme, characters_json
    )
}
```

从返回的 JSON 数据结构来看, 故事大纲并没有解决节点树的数据结构上存在的任何问题, 返回增加了不确定性

#### 分层生成策略

```rust
fn phase2_prompt(
    layer: usize,
    previous_layer: &[StoryNode],
    story_state: &StoryState,
    outline: &Outline,
) -> String {
    format!(
        r#"## 上下文
当前生成第{}层节点，前一层的节点：
{}

当前剧情状态：
- 角色好感度：{}
- 已触发的关键事件：{}

## 任务
生成本层（第{}层）的节点：
- 本层最多生成{}个节点（根据剧情复杂度决定）
- 每个节点必须继承前一层的剧情状态
- 节点ID范围：{}-{}
- 设计时考虑：{}
  * 剧情收束点（多个前驱指向同一个节点）
  * 分支扩展点（创造新的分支）
  * 快速结局路径（可选直接结局）

## 特别要求
1. 状态继承：必须包含前驱节点的关键状态
2. 冲突升级：比前一层增加紧张度
3. 角色互动：至少2个角色互动
4. 选项设计：大多数节点2个选项，10%以下1个选项

## 输出格式
{{
    "layer": {},
    "nodes": [
        {{
            "id": "字符串数字",
            "content": "45-65字第一人称叙述",
            "characters": ["角色1", "角色2"],
            "choices": [
                {{
                    "text": "选项文本",
                    "nextNodeId": "下一节点ID或结局key",
                    "affinityEffect": {{"character": "角色", "delta": 数字}} // 可选
                }}
            ],
            "inherited_states": ["之前的关键状态"],
            "new_states": ["本节点新增的状态"]
        }}
    ]
}}
"#,
        layer,
        format_previous_layer(previous_layer),
        format_affinities(story_state),
        format_story_flags(story_state),
        layer,
        calculate_max_nodes(layer),
        calculate_id_range(layer).0,
        calculate_id_range(layer).1,
        get_layer_design_notes(layer),
        layer
    )
}
```

#### DeepSeek 方案的缺点

此方案实际上与 ChatGPT 基本方案一致, 但实际不如 ChatGPT 方案, 因为

- 剧情大纲完全没有解决节点树结构存在的任何问题
- 分层生成实际与每个节点单独生成没有区别, 并没有解决实际问题

所以是个方案依然是失败的

### Gemini 有节奏感的剧情树设计
[点击这里](https://gemini.google.com/share/3359fe7f9880) 查看完整对话

#### 生成纯逻辑的节点树骨架
跟 ChatGPT 方案相似, 先生成节点树结构, 每个节点只生成:

- `nodeId`
- `level`
- `choices` (仅包含 `text` 的简写和 `nextNodeId`)
- 剧情摘要 (`Summary`): 用一句话描述这个节点发生了什么（例如：“主角潜入实验室被发现”）。

这里不仅生成了 剧情摘要, 还生成了 每个选项的 内容 / nextNodeId

#### 剧本节拍
剧本节拍