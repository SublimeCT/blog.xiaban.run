---
title: AI 互动剧情类游戏生成工具开发记录2 - 构建工作流
published: 2026-01-08
description: '在上一篇文章中, 介绍了一下我要做的互动剧情类游戏生成器, 然后分析了目前面临的严重影响使用的问题, 现在我们来通过构建工作流的方式来解决这些问题'
image: './assets/images/movie-games-optimize-cover.png'
tags: [
  '工作流',
  '构建工作流',
  'Vibe Coding',
  'AI',
  'Movie Games',
  'GLM',
  'DeepSeek',
  'ChatGPT',
  '互动电影游戏',
  '互动剧情类游戏',
  '互动剧情类游戏生成器',
]
category: '探索'
draft: true 
lang: 'zh-CN'
---

在 [上一篇文章](/movie-games-record) 中, 介绍了一下我要做的互动剧情类游戏生成器, 然后分析了目前面临的严重影响使用的问题, 现在我们来通过构建工作流的方式来解决这些问题

## 失败的设计
在现有的设计方案中, **我把一切都交给了 LLM**, 并且在 `propmpt` 中精心编写了各种限制, 我本以为它会生成符合所有要求的 `JSON`, 但是总是出现各种问题

倘若这是一个没有与 LLM 交互的项目, 那总会找到解决方案, 因为 **程序输出的结果是确定的, 而 LLM 输出的结构是不确定的**

### 超长的上下文

现有的提示词(**已省略部分内容**)如下:
```markdown
# 角色定义
你是一位享誉全球的互动电影游戏编剧和总导演。你擅长创作引人入胜、逻辑严密且充满情感冲击力的多分支剧情。 你的任务是根据用户提供的主题，创作一个完整的互动电影剧本，并将其直接输出为符合 TypeScript 接口定义的 JSON 格式。

# 用户输入主题
{}
# 一、核心叙事与风格要求
- 第一人称沉浸式叙事：所有的 `node.content` 必须使用 **第一人称 ("我")** 进行叙述。玩家就是主角，代入感必须极强。
- 剧情深度与质量：
    - 拒绝流水账、拒绝平铺直叙、拒绝假大空。
    - 必须具备电影剧本般的 **真实感、细腻度与情感张力**。
    - 严禁任何无意义的故事情节或重复啰嗦的废话。
- 语言指定：所有剧情内容必须使用 **{}** 撰写。

# 二、基础结构与格式约束
- JSON 结构规范：
  - 严格遵循下方的 `TypeScript` 类型定义。
  - 禁止返回 `meta` / `projectId` / `nodes[].id` / `version` / `owner` / `provenance` 等字段。
  - 结局分离：所有的结局节点必须定义在顶层的 `endings` 字段中。
  - ID 格式：
    - `nodes` 的 Key 必须是 **纯数字字符串** (例如 "1", "2", "3"...)。
    - **绝对禁止** 使用 `n_` 前缀 (如 `n_1`, `n_start` 等都是错误的)。
    - 唯一例外：起始节点的 Key 必须固定为 **"start"**。
  - 结局引用：`StoryNode` 中的 `choices` 若指向结局，必须引用 `endings` 中的 key。

# 三、数值硬性约束 (校验失败将视为错误)
- 节点总数：`nodes` 的数量必须在 **45 到 85** 之间。
- 结局数量：`endings` 的数量必须在 **4 到 6** 之间。
- 单节点字数：每个节点的 `content` (AI 智能扩写) 字数必须严格控制在 **45 到 65 字** 之间。
- 节点内容：每个节点的 `content` 禁止出现任何中文或者英文的双引号, 双引号必须使用单引号代替
- 路径深度：必须保证绝大多数的故事线都经过 **至少 12 个节点**。

...
# 六、结局触发机制
- 灵活结局：`endings` 的 Key 不再固定，可以根据剧情自由命名 (如 `ending_hero`, `ending_regret` 等)。
- 结局描述：每个结局的 `description` 长度不能超过 **40 个字**。
- 快速通道：**必须包含一个可以快速到达的结局路径**。
  - 例如：从 Start -> 节点 3 -> 节点 5 -> (选择某选项) -> 直接到达结局。
  - 也就是说，在较早的层级 (如 Level 3-5) 就允许通过特定选项直接进入结局。
- 互斥规则：
  - `nodes` 中的节点 **不允许** 包含 `endingKey` 属性。
  - 结局只能通过 `choices.nextNodeId` 指向 `endings` 的 Key 来触发。

# 用户提供的角色清单 (JSON)
{}
# TypeScript 类型定义 (Schema)
typescript {}
# 输出规则
- 输出必须是 **纯 JSON** 文本。
- **不要** 包含 markdown 代码块标记。
- `nodes` 数量：**45~85**。
- `endings` 数量：**3~6**。
- 必须包含 `start` 节点。
- 禁止出现任何游离节点(从 start 节点开始到达不了的节点)
- **每层节点数量不能超过 5 个, 在每次输出节点时都要检查是否超过这个数量值**
- **必须从最开始就要规划节点数量, 任何节点的选项引用的节点 id 都不允许超过这个数量值**
开始创作！
```

其中的 `{}` 是用户的输入(标题 / 简介 / 角色列表) 还有 `ts` 类型定义

此时 LLM 同时承担了:
- 🎨 高质量文学创作（电影级叙事）
- 🧠 全局规划（45–85 节点、12–15 层、选项比例、收束率）
- 🧮 严格数学约束满足（DAG、ID 递增、层级宽度、百分比）
- 🧾 精确 JSON Schema 输出

最终造成了 LLM 在 **长上下文生成** 时出现了 遗忘 / 幻觉 / 格式约束失败 的问题

> [!TIP]
> 出现问题的原因并不是因为 `prompt` 写的不够详细, 而是因为
> - **超长的内容已经超过了 `LLM` 输出稳定性的边界**
> - **`LLM` 并不会对剧情内容进行反复打磨, 而是一次性生成**
> - **约束越多, 输出越趋同和保守**
> - **模型并不会 记住整部故事，它只是在概率上 看过**

### 剧情树设计存在的问题

![现有的剧情树设计](./assets/images/movie-games-optimize-mow.excalidraw.svg)

以上是现有的剧情树设计, 上方是剧情树中的节点, 下方是结局节点, 从 `Start Node` 节点开始, 每个节点都指向下一个层级(`level`)的某个节点(或者结局节点), 最终到达 `Endings` 节点结束, 通过设计图很容易发现一些问题:

- 生成了 `21` 个节点, 最终玩家游玩一次只经过 `3 ~ 7` 个节点, 实际节点利用率只有 `14%` ~ `33%`, **大部分节点是玩家必须多次游玩才能到达, 但实际上很少会有玩家会玩第二次**
- 上一篇文章介绍的 [剧情状态丢失](../movie-games-record/#剧情状态丢失) 问题

## 拆解
为了解决在长上下文场景下大模型输出的不确定性问题, 我们可以将 prompt 拆解为多个 promot, 这样做就能做到:

- 每个 prompt 只完成一件事
- 减少每个 prompt 的长度
- 缩短整个剧情生成的时间

### Prompt A 节点规划
这个 Prompt 只做一件事: **不关注具体的剧情内容, 只生成剧情数的结构**, 具体职责为:

- 确定 `Level` 层数
- 每个 `Level` 的节点数
- 哪些 `Level` 是收束点
- 哪些节点是复用节点
- 哪些节点允许直达结局
- 确定 **关键节点**

> [!TIP]
> 关键节点指的是: 包含必然会影响剧情走向选项的节点

#### 剧情状态
在互动电影游戏中, 在每个节点都要进行选择, 我们可以将选择分为两类:
- 不影响后续剧情
- 影响后续剧情, 例如玩家选择了干掉某个角色, 那么在后续的剧情中肯定就不会出现这个角色了

对于 **影响后续剧情** 的选项, 我们自然要

#### 世界状态
世界状态(`World State`)

### Prompt B 生成起始节点和结局节点
由于起始节点和结局节点的特殊性, 需要先进行生成

### Prompt C 好感度数据
好感度系统是基于角色的 **剧情状态** 设计方式, 在众多游戏中, 都或多或少的存在好感度系统, 例如:

- 玩家选择了某个支线任务, 与某个角色共同完成了某段剧情, 在后续的主线中就会再次遇到这个角色, 而如果不做这个支线任务, 就不会遇到他
- 需要做出一系列偏向与某个角色的选择, 后续才能进入此角色的故事线

### Prompt D 节点内容生成
这个 Prompt 只做一件事: **生成单个节点内容**, 具体实现为:

在 prompt 中加入 `Prompt A` 生成的某个节点的信息, 包含:
- 故事的基本信息
- 有几个选项
- 起始节点和结局节点



